<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Building a distributed cron - spy16</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="Building a distributed cron"><meta itemprop=description content="I was constantly running into use-cases where things needed to be done
as per a pre-defined schedule. This post summarises the problem and solution."><meta itemprop=datePublished content="2022-03-03T11:01:59+05:30"><meta itemprop=dateModified content="2022-03-03T11:01:59+05:30"><meta itemprop=wordCount content="874"><meta itemprop=keywords content="redis,scheduler,cron,"><meta property="og:title" content="Building a distributed cron"><meta property="og:description" content="I was constantly running into use-cases where things needed to be done
as per a pre-defined schedule. This post summarises the problem and solution."><meta property="og:type" content="article"><meta property="og:url" content="https://spy16.in/posts/building-a-scheduler/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-03T11:01:59+05:30"><meta property="article:modified_time" content="2022-03-03T11:01:59+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building a distributed cron"><meta name=twitter:description content="I was constantly running into use-cases where things needed to be done
as per a pre-defined schedule. This post summarises the problem and solution."><link href="https://fonts.googleapis.com/css?family=Playfair+Display:700" rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://spy16.in/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://spy16.in/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://spy16.in/css/dark.css><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://spy16.in/js/main.js></script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://spy16.in/><img src="https://s.gravatar.com/avatar/07d369134a5308bfc99d1d5ae985e7f1?s=80" alt=spy16></a></div><h1 class=site-title><a href=https://spy16.in/>spy16</a></h1><div class=site-description><p>Poor attempts to convey my thoughts.</p><nav class="nav social"><ul class=flat><li><a href=https://github.com/spy16 title=Github><i data-feather=github></i></a></li><li><a href=/index.xml title=RSS><i data-feather=rss></i></a></li><li><a href=# class=scheme-toggle id=scheme-toggle></a></li></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Home</a></li><li><a href=/posts>All Posts</a></li><li><a href=/tags>Tags</a></li><li><a href=/about>About Me</a></li></ul></nav></div><div class=post><div class=post-head><div class=post-header><div class=meta><div class=date><span class=day>03</span>
<span class=rest>Mar 2022</span></div></div><div class=matter><h1 class=title>Building a distributed cron</h1></div></div><div class=tags><ul class=flat><li><a href=/tags/redis>redis</a></li><li><a href=/tags/scheduler>scheduler</a></li><li><a href=/tags/cron>cron</a></li></ul></div></div><button class=collapsible> ℹ️ &nbsp; Table of Contents</button><aside class="collapsible-content toc"><nav id=TableOfContents><ul><li><a href=#the-problem>The Problem</a></li><li><a href=#the-solution>The Solution</a><ul><li><a href=#creating>Creating</a></li><li><a href=#updating>Updating</a></li><li><a href=#deleting>Deleting</a></li><li><a href=#execution>Execution</a></li></ul></li></ul></nav></aside><div class=markdown><h2 id=the-problem>The Problem</h2><p>At work, I was constantly running into use-cases where things needed to be done
at a pre-defined time in the future and sometimes in a recurring manner (Similar to
unix cron<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>). For example, sending a reminder notification after 2 days, executing
some job for a user at configured interval, etc.</p><p>Considering the execution logic is different in every use-case, it made sense to think
of this problem in a generic sense reduce its overall requirement to just <em>emitting
events based on schedules</em>.</p><p>Let&rsquo;s say a schedule looks like this:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=font-weight:700>type</span> Schedule <span style=font-weight:700>struct</span> {
    ID      <span style=color:#458;font-weight:700>string</span> <span style=color:#b84>`yaml:&#34;id&#34;`</span>
    Crontab <span style=color:#458;font-weight:700>string</span> <span style=color:#b84>`yaml:&#34;crontab&#34;`</span>
    Payload <span style=color:#458;font-weight:700>string</span> <span style=color:#b84>`yaml:&#34;payload&#34;`</span>
}
</code></pre></div><p>An example schedule:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:navy>id</span>:<span style=color:#bbb> </span><span style=color:#b84>&#34;schedule1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:navy>crontab</span>:<span style=color:#bbb> </span><span style=color:#b84>&#34;@every 1h&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:navy>payload</span>:<span style=color:#bbb> </span><span style=color:#b84>&#39;{&#34;user&#34;: 1234, &#34;type&#34;: &#34;renewal_reminder&#34;}&#39;</span><span style=color:#bbb>
</span></code></pre></div><p>If the above schedule is created at <code>t</code>, we expect the scheduler to publish messages (e.g., over Kafka) with the following data at <code>t1=t+1h</code>, <code>t2=t1+1h</code>, and so on:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:navy>id</span>:<span style=color:#bbb> </span><span style=color:#b84>&#34;schedule1-&lt;tx&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:navy>generated_at</span>:<span style=color:#bbb> </span>&lt;tx&gt;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:navy>schedule_id</span>:<span style=color:#bbb> </span><span style=color:#b84>&#34;schedule1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:navy>payload</span>:<span style=color:#bbb> </span><span style=color:#b84>&#39;{&#34;user&#34;: 1234, &#34;type&#34;: &#34;renewal_reminder&#34;}&#39;</span><span style=color:#bbb>
</span></code></pre></div><p>Systems interested in these schedules would consume these messages and execute the business logic based on <code>payload</code>.</p><p>So in summary: <em>We needed a system that generates events based on schedules, has APIs to manage (i.e., CRUD) those schedules, is horizontally scalable, is highly-available (HA) & has no Single Point of Failure (SPOF).</em></p><figure><img src=/scheduler.png></figure><h2 id=the-solution>The Solution</h2><p>In case of never-ending recurring crontabs like <code>@every 1h</code>, all execution points cannot be inserted at the time of schedule creation because there are infinite execution points. So this will have to be done lazily - i.e., after handling one execution point, compute the next and enqueue it.</p><p>If we think of each crontab as series of timed execution points, what we really need is a job-queue where jobs are ready for dequeue at a specific time instead of being ready as soon as enqueued &ndash; A delay-queue.</p><p>So, this is rougly the interface we need to implement.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=font-weight:700>type</span> DelayQ <span style=font-weight:700>interface</span> {
    <span style=color:#998;font-style:italic>// Delay should enqueue item and ensure it becomes ready at
</span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// the given &#39;readyTime&#39;.
</span><span style=color:#998;font-style:italic></span>    <span style=color:#900;font-weight:700>Delay</span>(readyTime time.Time, data []<span style=color:#458;font-weight:700>byte</span>) <span style=color:#458;font-weight:700>error</span>

    <span style=color:#998;font-style:italic>// Run should continously look for ready items and invoke 
</span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// apply for each. This includes any item that was enqueued
</span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// with readyTime &lt;= time.Now().
</span><span style=color:#998;font-style:italic></span>    <span style=color:#900;font-weight:700>Run</span>(apply HandlerFn) <span style=color:#458;font-weight:700>error</span>
}

<span style=color:#998;font-style:italic>// HandlerFn is invoked by DelayQ for every ready item.
</span><span style=color:#998;font-style:italic></span><span style=font-weight:700>type</span> HandlerFn <span style=font-weight:700>func</span>(t time.Time, data []<span style=color:#458;font-weight:700>byte</span>) <span style=color:#458;font-weight:700>error</span>
</code></pre></div><p>For our scheduler use-case, the <code>HandlerFn</code> should:</p><ol><li>Publish the message with payload from the schedule.</li><li>Compute the next execution time and enqueue a job to be ready at that time.</li></ol><p>There are obviously multiple approaches to implementing the <code>DelayQ</code> interface ranging from in-memory priority-queue based solutions to distributed database solutions. I discuss implementing it with Redis in another post. For the purpose of this discussion, we will assume a <code>DelayQ</code> implementation exists and an instance is available as <code>dq</code>. We will also assume, there is a schedule definition storage that can be accessed using <code>saveSchedule</code>, <code>fetchSchedule</code>, etc.</p><p>With all this introduction and assumptions, we are ready to get to the workings of the system.</p><h3 id=creating>Creating</h3><p>We can create a schedule using:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=font-weight:700>func</span> <span style=color:#900;font-weight:700>createSchedule</span>(sc Schedule) <span style=color:#458;font-weight:700>error</span> {
    <span style=color:#998;font-style:italic>// enqueue the first execution point into delay-queue so
</span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// that we get a callback at that time.
</span><span style=color:#998;font-style:italic></span>    computeRelativeTo <span style=font-weight:700>:=</span> time.<span style=color:#900;font-weight:700>Now</span>()
    nextExecutionAt <span style=font-weight:700>:=</span> <span style=color:#900;font-weight:700>ComputeNext</span>(computeRelativeTo, sc.Crontab)
    err <span style=font-weight:700>:=</span> dq.<span style=color:#900;font-weight:700>Delay</span>(nextExecutionAt, sc.ID)
    <span style=font-weight:700>if</span> err <span style=font-weight:700>!=</span> <span style=font-weight:700>nil</span> {
        <span style=font-weight:700>return</span> err
    }

    <span style=color:#998;font-style:italic>// store into some persistent storage.
</span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// this is done after enqueue to make sure we don&#39;t end up
</span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// with schedules that were not enqueued properly and retry
</span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// is also not possible.
</span><span style=color:#998;font-style:italic></span>    <span style=font-weight:700>return</span> <span style=color:#900;font-weight:700>saveSchedule</span>(sc)
}
</code></pre></div><h3 id=updating>Updating</h3><p>Updating can be bit tricky if changing the <code>crontab</code> of an active schedule is allowed. Because updating the crontab changes the timeline of the schedule and most-likely makes the already inserted execution points in <code>DelayQ</code> invalid.</p><p>One way to handle this is to maintain a version on the schedule which changes on every update. This version should also be stored in the delay-queue as part of <code>data</code>. When it becomes ready, the <code>handle</code> function can compare the version from the <code>data</code> passed to the current version of the schedule-definition. If they do not match, ignore the callback.</p><h3 id=deleting>Deleting</h3><p>Deletion is as simple as removing the schedule definition from the storage. We don&rsquo;t really need to do anything about the execution point added to the delay-queue because the <code>handle</code> function ignores the callback if schedule is not found.</p><h3 id=execution>Execution</h3><p>So the worker setup would look like this:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=font-weight:700>package</span> main

<span style=font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
    <span style=color:#998;font-style:italic>// launch the worker threads that continously look for ready-items
</span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// &amp; invoke handler for those. 
</span><span style=color:#998;font-style:italic></span>    <span style=font-weight:700>if</span> err <span style=font-weight:700>:=</span> dq.<span style=color:#900;font-weight:700>Run</span>(handler); err <span style=font-weight:700>!=</span> <span style=font-weight:700>nil</span> {
        log.<span style=color:#900;font-weight:700>Fatalf</span>(<span style=color:#b84>&#34;delayq workers exited: %v&#34;</span>, err)
    }
}

<span style=font-weight:700>func</span> <span style=color:#900;font-weight:700>handle</span>(t time.Time, data []<span style=color:#458;font-weight:700>byte</span>) <span style=color:#458;font-weight:700>error</span> {
    scheduleID <span style=font-weight:700>:=</span> <span style=color:#999>string</span>(data)
    scheduleDef, found <span style=font-weight:700>:=</span> <span style=color:#900;font-weight:700>fetchSchedule</span>(scheduleID)
    <span style=font-weight:700>if</span> !found {
        <span style=color:#998;font-style:italic>// the schedule was probably deleted. so nothing to do.
</span><span style=color:#998;font-style:italic></span>        <span style=font-weight:700>return</span> <span style=font-weight:700>nil</span>
    }

    <span style=color:#998;font-style:italic>// next execution point should be computed relative to current
</span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// execution to establish the correct timeline that matches the
</span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// crontab.
</span><span style=color:#998;font-style:italic></span>    nextAt <span style=font-weight:700>:=</span> <span style=color:#900;font-weight:700>ComputeNext</span>(t, scheduleDef.Crontab)
    err <span style=font-weight:700>:=</span> dq.<span style=color:#900;font-weight:700>Delay</span>(nextAt, scheduleID)
    <span style=font-weight:700>if</span> err <span style=font-weight:700>!=</span> <span style=font-weight:700>nil</span> {
        <span style=font-weight:700>return</span> err
    }

    <span style=color:#998;font-style:italic>// if enqueue is successful, we publish the event to notify external
</span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// systems. if this fails, the DelayQ will end-up retrying.
</span><span style=color:#998;font-style:italic></span>    <span style=font-weight:700>return</span> <span style=color:#900;font-weight:700>publishEvent</span>(Event{
        ID: fmt.<span style=color:#900;font-weight:700>Sprintf</span>(<span style=color:#b84>&#34;%s-%s&#34;</span>, scheduleID, t.<span style=color:#900;font-weight:700>Unix</span>()),
        Payload: scheduleDef.Payload,
        ScheduleID: scheduleID,
        GeneratedAt: t,
    })
}
</code></pre></div><p>With this setup running, we should start seeing events being published as expected by the system for any active schedules.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://man7.org/linux/man-pages/man8/cron.8.html>https://man7.org/linux/man-pages/man8/cron.8.html</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><hr id=disqus_separator><div id=disqus_thread></div><script type=text/javascript>(function(){var a,b;if(window.location.hostname=="localhost"){document.getElementById('disqus_separator').hidden=!0;return}a=document.createElement('script'),a.type='text/javascript',a.async=!0,b='spy16-in',a.src='//'+b+'.disqus.com/embed.js',(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(a)})()</script><noscript>Please enable JavaScript to view the</a></noscript></div><div class="footer wrapper"><nav class=nav><div>2022 © Shivaprasad Bhat | <a href=https://github.com/knadh/hugo-ink>Ink</a> based theme on <a href=https://gohugo.io>Hugo</a></div></nav></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-E57FGYYMSF"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-E57FGYYMSF',{anonymize_ip:!1})}</script><script>feather.replace()</script></div></body><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script><script>var coll=document.getElementsByClassName("collapsible"),i;for(i=0;i<coll.length;i++)coll[i].addEventListener("click",function(){this.classList.toggle("active");var a=this.nextElementSibling;a.style.display==="block"?a.style.display="none":a.style.display="block"})</script></html>